<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Dissensus - Governance alignment research for multi-agent systems. Formalizing productive friction in the age of AI.">

  <!-- Open Graph -->
  <meta property="og:title" content="Dissensus | Governance Alignment Research">
  <meta property="og:description" content="Formalizing productive friction in multi-agent systems.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://dissensus.ai">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Dissensus | Governance Alignment Research">
  <meta name="twitter:description" content="Formalizing productive friction in multi-agent systems.">

  <title>Dissensus | Governance Alignment Research</title>

  <link rel="stylesheet" href="css/dissensus.css">

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23050505' width='100' height='100'/><text x='50' y='68' font-family='monospace' font-size='60' fill='%23DC143C' text-anchor='middle'>D</text></svg>">
</head>
<body>

  <!-- Hero -->
  <section class="hero">
    <canvas id="network" class="hero__canvas"></canvas>
    <div class="container">
      <h1 class="hero__title">DISSENSUS</h1>
      <p class="hero__tagline">Axiomatic Consent Mechanics and Tripartite Friction Topology in Substrate-Agnostic Replication-Optimizing Multi-Agent Networks: Toward a Phenomenologically-Contained Metatheoretic Foundation for Pre-Strategic Delegation Dynamics Across Scale-Invariant Coordination Substrates with Applications to Decentralized Systems, Machine Morality, and Political Economy</p>
      <p class="hero__subtitle">Or simply: coordination has overhead.</p>
    </div>
  </section>

  <!-- About -->
  <section class="about" data-index="01">
    <div class="container">
      <h2>The Problem</h2>
      <p>
        Game theory assumes you're already in a game. It doesn't explain how you got there,
        why the payoffs look the way they do, or what happens when someone refuses to play.
      </p>
      <p>
        I kept running into this while studying crypto markets. Regulators announce things,
        sentiment moves, but the network doesn't care. The protocol isn't in their game.
        There's a layer underneath that nobody was formalizing.
      </p>

      <div class="equation">
        Friction = f(alignment, stake, entropy)<br><br>
        <span class="eq-detail">Alignment = convergence/divergence of optimization targets</span><br>
        <span class="eq-detail">Stake = magnitude of optimization being delegated</span><br>
        <span class="eq-detail">Entropy = efficiency loss in optimization transfer</span>
      </div>

      <p>
        So I started writing it down. Delegation produces friction. Friction has structure.
        Structure is measurable. The same pattern shows up in markets, institutions, AI systems,
        basically anywhere agents have to coordinate.
      </p>
    </div>
  </section>

  <!-- Research Focus -->
  <section class="research" data-index="02">
    <div class="container">
      <h2>Current Work</h2>
      <div class="research-grid">

        <article class="research-card">
          <span class="research-card__index">01</span>
          <h3>Market Microstructure</h3>
          <p>Why regulatory events affect sentiment but not network dynamics. Empirical validation of consent layer theory.</p>
        </article>

        <article class="research-card">
          <span class="research-card__index">02</span>
          <h3>Computational Methods</h3>
          <p>Running AI agents through governance scenarios. Monte Carlo stress-testing of delegation structures.</p>
        </article>

        <article class="research-card">
          <span class="research-card__index">03</span>
          <h3>Formal Framework</h3>
          <p>The Axiom of Consent. Currently in bits across multiple papers&mdash;friction decomposition, substrate-independence, epistemic containment.</p>
        </article>

        <article class="research-card">
          <span class="research-card__index">04</span>
          <h3>Applied Domains</h3>
          <p>Political legitimacy, AI alignment, institutional design. Same framework, different substrates.</p>
        </article>

      </div>
      <p class="research-note">Published work and preprints at <a href="https://farzulla.org" target="_blank" rel="noopener">farzulla.org</a></p>
    </div>
  </section>

  <!-- Foundational Work -->
  <section class="foundation" data-index="03">
    <div class="container">
      <h2>The Paper</h2>
      <a href="#" class="paper-link">
        <span class="paper-link__label">Working Paper</span>
        <h3>The Axiom of Consent</h3>
        <p>
          The whole framework in one document. Multi-agent interaction requires delegation,
          delegation produces friction, friction is measurable. Tautological but useful.
          Started as notes, became a theory, still being stress-tested.
        </p>
        <div class="meta">
          <span>2025</span>
          <span>In progress</span>
        </div>
      </a>
    </div>
  </section>

  <!-- Who -->
  <section class="team" data-index="04">
    <div class="container">
      <h2>Who</h2>
      <div class="founder">
        <div class="founder__avatar">MF</div>
        <div class="founder__info">
          <h3 class="founder__name">Murad Farzulla</h3>
          <p class="founder__bio">
            Finance background, fell into computational research, now I can't stop
            formalizing things. Currently finishing an MSc at King's, in talks with
            supervisors on agent-based modelling and econometric analysis work.
            This started as a market paper and turned into whatever this is.
          </p>
          <div class="founder__links">
            <a href="https://farzulla.com" target="_blank" rel="noopener">farzulla.com</a>
            <a href="https://orcid.org/0009-0002-7164-8704" target="_blank" rel="noopener">ORCID</a>
            <a href="https://github.com/studiofarzulla" target="_blank" rel="noopener">GitHub</a>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Contact -->
  <section class="contact" data-index="05">
    <div class="container">
      <h2>Contact</h2>
      <div class="contact__wrapper">
        <a href="mailto:lab@dissensus.ai" class="email">lab@dissensus.ai</a>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer>
    <div class="container">
      <p>&copy; 2025</p>
    </div>
  </footer>

  <!-- Network Visualization -->
  <script>
    (function() {
      const canvas = document.getElementById('network');
      const ctx = canvas.getContext('2d');

      // Colors
      const NODE_COLOR = 'rgba(220, 20, 60, 0.4)';
      const NODE_COLOR_ACTIVE = 'rgba(220, 20, 60, 0.8)';
      const EDGE_COLOR = 'rgba(220, 20, 60, 0.1)';
      const EDGE_COLOR_ACTIVE = 'rgba(220, 20, 60, 0.3)';

      // Config
      const NODE_COUNT = 60;
      const CONNECTION_DISTANCE = 200;
      const NODE_SIZE = 2;
      const MOUSE_RADIUS = 150;

      let nodes = [];
      let mouse = { x: null, y: null };
      let animationId;

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      function createNodes() {
        nodes = [];
        for (let i = 0; i < NODE_COUNT; i++) {
          nodes.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            size: NODE_SIZE + Math.random() * 2
          });
        }
      }

      function distance(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
      }

      function update() {
        for (const node of nodes) {
          // Move
          node.x += node.vx;
          node.y += node.vy;

          // Bounce off edges
          if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
          if (node.y < 0 || node.y > canvas.height) node.vy *= -1;

          // Keep in bounds
          node.x = Math.max(0, Math.min(canvas.width, node.x));
          node.y = Math.max(0, Math.min(canvas.height, node.y));
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw edges
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const d = distance(nodes[i], nodes[j]);
            if (d < CONNECTION_DISTANCE) {
              const opacity = 1 - (d / CONNECTION_DISTANCE);

              // Check if near mouse
              const mouseDistI = mouse.x !== null ? distance(nodes[i], mouse) : Infinity;
              const mouseDistJ = mouse.x !== null ? distance(nodes[j], mouse) : Infinity;
              const nearMouse = mouseDistI < MOUSE_RADIUS || mouseDistJ < MOUSE_RADIUS;

              ctx.beginPath();
              ctx.moveTo(nodes[i].x, nodes[i].y);
              ctx.lineTo(nodes[j].x, nodes[j].y);
              ctx.strokeStyle = nearMouse
                ? `rgba(220, 20, 60, ${opacity * 0.4})`
                : `rgba(220, 20, 60, ${opacity * 0.1})`;
              ctx.lineWidth = nearMouse ? 1 : 0.5;
              ctx.stroke();
            }
          }
        }

        // Draw nodes
        for (const node of nodes) {
          const mouseDist = mouse.x !== null ? distance(node, mouse) : Infinity;
          const nearMouse = mouseDist < MOUSE_RADIUS;
          const scale = nearMouse ? 1 + (1 - mouseDist / MOUSE_RADIUS) * 0.5 : 1;

          ctx.beginPath();
          ctx.arc(node.x, node.y, node.size * scale, 0, Math.PI * 2);
          ctx.fillStyle = nearMouse ? NODE_COLOR_ACTIVE : NODE_COLOR;
          ctx.fill();

          // Glow effect for active nodes
          if (nearMouse) {
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.size * scale * 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(220, 20, 60, 0.1)';
            ctx.fill();
          }
        }
      }

      function animate() {
        update();
        draw();
        animationId = requestAnimationFrame(animate);
      }

      function handleMouseMove(e) {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      }

      function handleMouseLeave() {
        mouse.x = null;
        mouse.y = null;
      }

      // Initialize
      resize();
      createNodes();
      animate();

      // Events
      window.addEventListener('resize', () => {
        resize();
        createNodes();
      });

      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseleave', handleMouseLeave);

      // Reduce animation when not visible
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          cancelAnimationFrame(animationId);
        } else {
          animate();
        }
      });
    })();
  </script>

</body>
</html>
