<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Dissensus - Governance alignment research for multi-agent systems. Formalizing productive friction in the age of AI.">

  <!-- Open Graph -->
  <meta property="og:title" content="Dissensus | Governance Alignment Research">
  <meta property="og:description" content="Formalizing productive friction in multi-agent systems.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://dissensus.ai">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Dissensus | Governance Alignment Research">
  <meta name="twitter:description" content="Formalizing productive friction in multi-agent systems.">

  <title>Dissensus | Governance Alignment Research</title>

  <link rel="stylesheet" href="css/dissensus.css">

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23050505' width='100' height='100'/><text x='50' y='68' font-family='monospace' font-size='60' fill='%23DC143C' text-anchor='middle'>D</text></svg>">
</head>
<body>

  <!-- Hero -->
  <section class="hero">
    <canvas id="network" class="hero__canvas"></canvas>
    <div class="container">
      <h1 class="hero__title">DISSENSUS</h1>
      <p class="hero__tagline">Axiomatic Consent Mechanics and Tripartite Friction Topology in Substrate-Agnostic Replication-Optimizing Multi-Agent Networks: Toward a Phenomenologically-Contained Metatheoretic Foundation for Pre-Strategic Delegation Dynamics Across Scale-Invariant Coordination Substrates with Applications to Decentralized Systems, Machine Morality, and Political Economy</p>
      <p class="hero__subtitle">Or simply: coordination has overhead.</p>
    </div>
  </section>

  <!-- About -->
  <section class="about" data-index="01">
    <div class="container">
      <h2>The Problem</h2>
      <p>
        Game theory assumes you're already in a game. It doesn't explain how you got there,
        why the payoffs look the way they do, or what happens when someone refuses to play.
      </p>
      <p>
        We study the layer underneath. Before strategy, there is delegation. Before delegation, there is consent.
        Regulators announce things, sentiment moves, but the network doesn't care. The protocol isn't in their game.
      </p>

      <div class="equation">
        Friction = f(alignment, stake, entropy)<br><br>
        <span class="eq-detail">Alignment = convergence/divergence of optimization targets</span><br>
        <span class="eq-detail">Stake = magnitude of optimization being delegated</span><br>
        <span class="eq-detail">Entropy = efficiency loss in optimization transfer</span>
      </div>

      <p>
        We formalize this friction. Not to eliminate it, but to measure it. Friction is the cost of existence
        in an adversarial environment.
      </p>
    </div>
  </section>

  <!-- Research Programs -->
  <section class="research" data-index="02">
    <div class="container">
      <h2>Research Programs</h2>
      <div class="research-grid">

        <article class="research-card">
          <span class="research-card__index">I</span>
          <h3>The Axiom of Consent</h3>
          <p>
            Decomposing institutional friction into alignment, stake, and entropy. A unified framework for
            political legitimacy and algorithmic governance.
          </p>
        </article>

        <article class="research-card">
          <span class="research-card__index">II</span>
          <h3>Replicator Dynamics</h3>
          <p>
            The <strong>Replicator-Optimization Mechanism (ROM)</strong>. Formalizing the unity of optimization
            and replication across physical, biological, and abstract substrates.
          </p>
        </article>

        <article class="research-card">
          <span class="research-card__index">III</span>
          <h3>Adversarial Alignment</h3>
          <p>
            AI Safety as genre convention. Investigating how models mimic ethical reasoning through
            statistical reproduction of professional norms rather than moral cognition.
          </p>
        </article>

        <article class="research-card">
          <span class="research-card__index">IV</span>
          <h3>Economic Theory</h3>
          <p>
            Market reaction asymmetry and the hedging paradox. Empirical validation of friction dynamics
            in cryptocurrency and derivatives markets.
          </p>
        </article>

      </div>
      <p class="research-note">Full archive available at <a href="https://farzulla.org" target="_blank" rel="noopener">farzulla.org</a></p>
    </div>
  </section>

  <!-- Core Theory -->
  <section class="foundation" data-index="03">
    <div class="container">
      <h2>Core Theory</h2>
      <div class="theory-grid">
        <a href="https://farzulla.org/papers/consensual-sovereignty" class="paper-link" target="_blank" rel="noopener">
          <span class="paper-link__label">Working Paper</span>
          <h3>The Doctrine of Consensual Sovereignty</h3>
          <p>
            Quantifying legitimacy in adversarial environments. The foundational text of the Axiom of Consent framework.
          </p>
          <div class="meta">
            <span>2025</span>
            <span>Political Economy</span>
          </div>
        </a>

        <a href="https://farzulla.org/papers/replicator-optimization-mechanism" class="paper-link" target="_blank" rel="noopener">
          <span class="paper-link__label">Preprint</span>
          <h3>The Replicator-Optimization Mechanism</h3>
          <p>
            A scale-relative formalism for persistence-conditioned dynamics. How systems maintain identity through change.
          </p>
          <div class="meta">
            <span>2025</span>
            <span>Meta-Theory</span>
          </div>
        </a>
      </div>
    </div>
  </section>

  <!-- Network / Collab -->
  <section class="network" data-index="04">
    <div class="container">
      <h2>The Network</h2>
      <div class="network-content">
        <p>
          Dissensus operates as a distributed research node. We are not interested in corporate alignment or
          sterile academic consensus. We are interested in the mechanics of friction.
        </p>
        <p>
          We seek collaborators to pressure-test these frameworks:
        </p>
        <ul class="collab-list">
          <li><strong>Physicists</strong> to break the Temporal Bitmap Interpretation.</li>
          <li><strong>Economists</strong> to challenge the Hedging Paradox.</li>
          <li><strong>Philosophers</strong> to dismantle the Axiom of Consent.</li>
          <li><strong>AI Researchers</strong> to attack the Genre Mimicry hypothesis.</li>
        </ul>
        <p class="collab-cta">
          If you want to break things, get in touch.
        </p>
      </div>
    </div>
  </section>

  <!-- Who -->
  <section class="team" data-index="05">
    <div class="container">
      <h2>Lead Investigator</h2>
      <div class="founder">
        <div class="founder__avatar">MF</div>
        <div class="founder__info">
          <h3 class="founder__name">Murad Farzulla</h3>
          <p class="founder__bio">
            Independent researcher focused on formalizing friction dynamics in complex adaptive systems. 
            Creator of the Axiom of Consent framework and the Replicator-Optimization Mechanism. 
            Developed the Resurrexi infrastructure to support high-throughput social simulation and 
            agent-based modeling. Seeking institutional partnership to scale these frameworks into a 
            dedicated computational complexity lab.
          </p>
          <div class="founder__links">
            <a href="https://farzulla.org" target="_blank" rel="noopener">Research</a>
            <a href="https://resurrexi.io" target="_blank" rel="noopener">Lab</a>
            <a href="https://resurrexi.dev" target="_blank" rel="noopener">Logs</a>
            <a href="https://github.com/studiofarzulla" target="_blank" rel="noopener">GitHub</a>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Contact -->
  <section class="contact" data-index="06">
    <div class="container">
      <h2>Signal</h2>
      <div class="contact__wrapper">
        <a href="mailto:lab@dissensus.ai" class="email">lab@dissensus.ai</a>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer>
    <div class="container">
      <p>&copy; 2025 Dissensus Research. <span style="opacity: 0.5;">Entropy is inevitable.</span></p>
    </div>
  </footer>

  <!-- Network Visualization -->
  <script>
    (function() {
      const canvas = document.getElementById('network');
      const ctx = canvas.getContext('2d');

      // Colors
      const NODE_COLOR = 'rgba(220, 20, 60, 0.4)';
      const NODE_COLOR_ACTIVE = 'rgba(220, 20, 60, 0.8)';
      const EDGE_COLOR = 'rgba(220, 20, 60, 0.1)';
      const EDGE_COLOR_ACTIVE = 'rgba(220, 20, 60, 0.3)';

      // Config
      const NODE_COUNT = 60;
      const CONNECTION_DISTANCE = 200;
      const NODE_SIZE = 2;
      const MOUSE_RADIUS = 150;

      let nodes = [];
      let mouse = { x: null, y: null };
      let animationId;

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      function createNodes() {
        nodes = [];
        for (let i = 0; i < NODE_COUNT; i++) {
          nodes.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 0.5,
            vy: (Math.random() - 0.5) * 0.5,
            size: NODE_SIZE + Math.random() * 2
          });
        }
      }

      function distance(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
      }

      function update() {
        for (const node of nodes) {
          // Move
          node.x += node.vx;
          node.y += node.vy;

          // Bounce off edges
          if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
          if (node.y < 0 || node.y > canvas.height) node.vy *= -1;

          // Keep in bounds
          node.x = Math.max(0, Math.min(canvas.width, node.x));
          node.y = Math.max(0, Math.min(canvas.height, node.y));
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw edges
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const d = distance(nodes[i], nodes[j]);
            if (d < CONNECTION_DISTANCE) {
              const opacity = 1 - (d / CONNECTION_DISTANCE);

              // Check if near mouse
              const mouseDistI = mouse.x !== null ? distance(nodes[i], mouse) : Infinity;
              const mouseDistJ = mouse.x !== null ? distance(nodes[j], mouse) : Infinity;
              const nearMouse = mouseDistI < MOUSE_RADIUS || mouseDistJ < MOUSE_RADIUS;

              ctx.beginPath();
              ctx.moveTo(nodes[i].x, nodes[i].y);
              ctx.lineTo(nodes[j].x, nodes[j].y);
              ctx.strokeStyle = nearMouse
                ? `rgba(220, 20, 60, ${opacity * 0.4})`
                : `rgba(220, 20, 60, ${opacity * 0.1})`;
              ctx.lineWidth = nearMouse ? 1 : 0.5;
              ctx.stroke();
            }
          }
        }

        // Draw nodes
        for (const node of nodes) {
          const mouseDist = mouse.x !== null ? distance(node, mouse) : Infinity;
          const nearMouse = mouseDist < MOUSE_RADIUS;
          const scale = nearMouse ? 1 + (1 - mouseDist / MOUSE_RADIUS) * 0.5 : 1;

          ctx.beginPath();
          ctx.arc(node.x, node.y, node.size * scale, 0, Math.PI * 2);
          ctx.fillStyle = nearMouse ? NODE_COLOR_ACTIVE : NODE_COLOR;
          ctx.fill();

          // Glow effect for active nodes
          if (nearMouse) {
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.size * scale * 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(220, 20, 60, 0.1)';
            ctx.fill();
          }
        }
      }

      function animate() {
        update();
        draw();
        animationId = requestAnimationFrame(animate);
      }

      function handleMouseMove(e) {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      }

      function handleMouseLeave() {
        mouse.x = null;
        mouse.y = null;
      }

      // Initialize
      resize();
      createNodes();
      animate();

      // Events
      window.addEventListener('resize', () => {
        resize();
        createNodes();
      });

      canvas.addEventListener('mousemove', handleMouseMove);
      canvas.addEventListener('mouseleave', handleMouseLeave);

      // Reduce animation when not visible
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          cancelAnimationFrame(animationId);
        } else {
          animate();
        }
      });
    })();
  </script>

</body>
</html>